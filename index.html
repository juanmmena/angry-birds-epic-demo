<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Angry Birds Epic - Fan Demo (Improved)</title>
  <style>
    :root{--ui-bg:rgba(255,255,255,0.98);--accent:#f05d5d}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#bfe9ff,#f0f9ff);padding:18px}
    .wrap{width:100%;max-width:1200px;background:var(--ui-bg);border-radius:14px;box-shadow:0 18px 40px rgba(20,30,60,0.12);display:grid;grid-template-columns:1fr 360px;gap:16px;padding:16px}
    canvas{width:100%;height:100%;background:transparent;border-radius:10px;display:block}
    .sidebar{padding:12px}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:10px}
    button{padding:10px 14px;border-radius:10px;border:0;background:#2e6bff;color:white;font-weight:700;cursor:pointer;box-shadow:0 6px 14px rgba(46,107,255,0.18)}
    button.disabled{opacity:0.45;pointer-events:none}
    #log{height:300px;overflow:auto;background:#fff;border-radius:10px;padding:10px;border:1px solid #eee}
    .hpbar{height:10px;background:#eee;border-radius:999px;overflow:hidden}
    .hpfill{height:100%;background:linear-gradient(90deg,#ff9b9b,#ff5d5d)}
    .small{font-size:13px;color:#333}
    .center{display:flex;align-items:center;justify-content:center}
    .title{font-weight:800;margin-bottom:6px}
    .muted{color:#666;font-size:13px}
    .row{display:flex;gap:10px;align-items:center;margin-bottom:8px}
    .sprite-preview{width:44px;height:44px;border-radius:10px;background:#eee;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .footer{font-size:12px;color:#666;margin-top:8px}
    .credits{font-size:12px;color:#999;margin-top:10px}
    @media(max-width:1000px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div style="padding:8px">
      <canvas id="gameCanvas" width="960" height="540"></canvas>
    </div>
    <aside class="sidebar">
      <div class="title">Controles</div>
      <div class="controls">
        <button id="btnAttack">Attack</button>
        <button id="btnDefend">Defend</button>
        <button id="btnSkill" class="disabled">Skill</button>
        <button id="btnRestart">Restart</button>
      </div>

      <div class="title">Equipo</div>
      <div id="partyStatus"></div>

      <div class="title" style="margin-top:8px">Battle log</div>
      <div id="log"></div>

      <div class="credits">Demo fan-made. Sprites cargados desde internet para uso personal. Si quieres sprites locales, crea una carpeta <code>assets/</code> con PNGs.</div>
    </aside>
  </div>

  <script>
  /* Improved fan demo
     - Mejor estética
     - Carga de sprites remotos (si están disponibles)
     - Ajustes de jugabilidad: daño/subida de stats, y comportamiento enemigo cambiado para que sea justo
     - Cambios clave: ahora **solo un cerdito** ataca después de cada acción del jugador (en vez de los 3 a la vez)
  */

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  canvas.width = 960 * DPR; canvas.height = 540 * DPR; ctx.scale(DPR, DPR);

  const btnAttack = document.getElementById('btnAttack');
  const btnDefend = document.getElementById('btnDefend');
  const btnSkill = document.getElementById('btnSkill');
  const btnRestart = document.getElementById('btnRestart');
  const logEl = document.getElementById('log');
  const partyStatus = document.getElementById('partyStatus');

  // Remote images (hosted on public PNG libraries / wikis) - si alguno faltara, el código usa placeholders.
  const ASSETS = {
    bg: 'https://www.vecteezy.com/download/preview/468864/angry-birds-background-by-user?format=png',
    players: [
      'https://www.kindpng.com/picc/m/430-4309383_angry-birds-fanon-wiki-angry-birds-sprites-red.png',
      'https://www.stickpng.com/assets/images/5842b3d2a6515b1e0ad75c46.png',
      'https://www.stickpng.com/assets/images/5842b3f6a6515b1e0ad75c4d.png'
    ],
    enemies: [
      'https://www.pikpng.com/pngvi/iJxTbx_pig-angry-birds-pig-png-transparent-png/',
      'https://www.pikpng.com/pngvi/iJxTbx_pig-angry-birds-pig-png-transparent-png/',
      'https://www.pikpng.com/pngvi/iJxTbx_pig-angry-birds-pig-png-transparent-png/'
    ]
  };

  function loadImage(src){
    return new Promise(resolve => {
      const img = new Image(); img.crossOrigin = 'anonymous';
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  // Tweak: balanced stats so the level sea "winnable".
  const defaultPlayers = [
    {id:'red', name:'Red', maxHp:120, hp:120, atk:36, color:'#ff4d4d'},
    {id:'chuck', name:'Chuck', maxHp:100, hp:100, atk:30, color:'#ffd24d'},
    {id:'bomb', name:'Bomb', maxHp:140, hp:140, atk:42, color:'#7b7b7b'}
  ];
  const defaultEnemies = [
    {id:'pig1', name:'Piglet', maxHp:70, hp:70, atk:18, color:'#9de58f'},
    {id:'pig2', name:'Coronapig', maxHp:95, hp:95, atk:20, color:'#93d88b'},
    {id:'pig3', name:'Big Pig', maxHp:130, hp:130, atk:24, color:'#75c26d'}
  ];

  let images = { bg:null, players:[], enemies:[] };
  let players = [], enemies = [];
  const leftX=140, rightX=820; const slotsY=[130,270,410];
  let selectingTarget=false, currentPlayerIndex=0, busy=false, floatingTexts=[], battleOver=false;

  function resetGame(){
    players = JSON.parse(JSON.stringify(defaultPlayers));
    enemies = JSON.parse(JSON.stringify(defaultEnemies));
    players.forEach((p,i)=>{ p.x=leftX; p.y=slotsY[i]; p.alive=true; p.sprite = images.players[i] || null; p.defending=false; });
    enemies.forEach((e,i)=>{ e.x=rightX; e.y=slotsY[i]; e.alive=true; e.sprite = images.enemies[i] || null; e.defending=false; });
    currentPlayerIndex=0; selectingTarget=false; busy=false; battleOver=false; floatingTexts=[];
    log('Battle started! Your turn: '+players[currentPlayerIndex].name);
    updateUI();
  }

  function log(text){ const p=document.createElement('div'); p.textContent=text; logEl.prepend(p); }
  function updateUI(){ partyStatus.innerHTML=''; players.forEach(p=>{ const wrap=document.createElement('div'); wrap.className='row small'; const preview=document.createElement('div'); preview.className='sprite-preview'; if(p.sprite){ const img=document.createElement('img'); img.src=p.sprite.src; img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; preview.appendChild(img); } else { preview.style.background=p.color; preview.textContent=p.name[0]; } const info=document.createElement('div'); info.innerHTML=`<div style="font-weight:700">${p.name}</div><div class="hpbar"><div class="hpfill" style="width:${Math.max(0,Math.round(100*p.hp/p.maxHp))}%"></div></div>`; wrap.appendChild(preview); wrap.appendChild(info); partyStatus.appendChild(wrap); }); }

  function calcDamage(att){ const variance = Math.floor(Math.random()*7)-2; return Math.max(1, att + variance); }
  function spawnFloating(x,y,text,color='#fff'){ floatingTexts.push({x,y,text,ttl:60,color}); }

  function drawBackground(){ if(images.bg){ ctx.drawImage(images.bg,0,0,canvas.width/DPR,canvas.height/DPR); return; } const W=canvas.width/DPR,H=canvas.height/DPR; const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#7ec8ff'); g.addColorStop(1,'#bfe9ff'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H); ctx.fillStyle='#66c36f'; ctx.beginPath(); ctx.ellipse(240,430,360,120,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#59b65f'; ctx.beginPath(); ctx.ellipse(540,440,460,140,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#7dbb59'; ctx.fillRect(0,470,W,70); ctx.fillStyle='#5b3b1e'; ctx.fillRect(80,430,200,20); ctx.fillRect(680,430,200,20); }

  function drawEntity(ent){ const size=96; ctx.save(); if(ent.sprite){ ctx.drawImage(ent.sprite, ent.x - size/2, ent.y - size/2, size, size); } else { ctx.beginPath(); ctx.arc(ent.x,ent.y,44,0,Math.PI*2); ctx.fillStyle=ent.color; ctx.fill(); ctx.lineWidth=4; ctx.strokeStyle='#00000022'; ctx.stroke(); ctx.fillStyle='#111'; ctx.font='bold 14px sans-serif'; ctx.textAlign='center'; ctx.fillText(ent.name,ent.x,ent.y+64); } const barW=110, barH=12; const hpPct=Math.max(0,ent.hp/ent.maxHp); ctx.fillStyle='rgba(0,0,0,0.18)'; ctx.fillRect(ent.x - barW/2, ent.y - 64, barW, barH); ctx.fillStyle='#ff6b6b'; ctx.fillRect(ent.x - barW/2, ent.y - 64, barW * hpPct, barH); ctx.strokeStyle='#00000033'; ctx.strokeRect(ent.x - barW/2, ent.y - 64, barW, barH); ctx.restore(); }

  function render(){ ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR); drawBackground(); enemies.forEach(e=>{ if(e.alive) drawEntity(e); }); players.forEach(p=>{ if(p.alive) drawEntity(p); }); for(let i=floatingTexts.length-1;i>=0;i--){ const f=floatingTexts[i]; ctx.font='bold 20px sans-serif'; ctx.fillStyle=f.color; ctx.textAlign='center'; ctx.fillText(f.text,f.x,f.y); f.y -= 0.7; f.ttl--; if(f.ttl<=0) floatingTexts.splice(i,1); } }

  function animateMove(ent,toX,toY,duration=360){ return new Promise(resolve=>{ const startX=ent.x,startY=ent.y,start=performance.now(); function frame(now){ const t=Math.min(1,(now-start)/duration); const ease = t<0.5 ? 2*t*t : -1 + (4 - 2*t)*t; ent.x = startX + (toX - startX) * ease; ent.y = startY + (toY - startY) * ease; if(t<1) requestAnimationFrame(frame); else resolve(); } requestAnimationFrame(frame); }); }

  async function performAttack(attacker, defender){ busy=true; const originalX=attacker.x, originalY=attacker.y; const hitX = defender.x - (attacker.x < defender.x ? 72 : -72); await animateMove(attacker, hitX, defender.y, 260); const dmg = calcDamage(attacker.atk); defender.hp = Math.max(0, defender.hp - dmg); spawnFloating(defender.x, defender.y - 16, '-' + dmg, '#ffe'); log(`${attacker.name} hits ${defender.name} for ${dmg} dmg`); await new Promise(r=>setTimeout(r,240)); await animateMove(attacker, originalX, originalY, 240); if(defender.hp<=0){ defender.alive=false; log(defender.name + ' was defeated!'); spawnFloating(defender.x, defender.y, 'KO', '#ffb'); } busy=false; updateUI(); }

  function getAlive(arr){ return arr.filter(x=>x.alive); }

  // KEY GAME CHANGE: enemies act one at a time after each player action (not all together)
  async function enemySingleAction(){
    const aliveEnemies = getAlive(enemies);
    if(!aliveEnemies.length) return;
    // pick one random alive enemy to act
    const enemy = aliveEnemies[Math.floor(Math.random()*aliveEnemies.length)];
    if(!enemy.alive) return;
    const targetCandidates = getAlive(players);
    if(!targetCandidates.length) return;
    const target = targetCandidates[Math.floor(Math.random()*targetCandidates.length)];
    busy=true; log(`Enemy ${enemy.name} attacks ${target.name}`);
    await performAttack(enemy, target);
    busy=false;
    checkEndConditions();
    // move turn to next alive player
    if(getAlive(players).length && getAlive(enemies).length){
      do { currentPlayerIndex = (currentPlayerIndex + 1) % players.length; } while(!players[currentPlayerIndex].alive);
      log('Your turn: ' + players[currentPlayerIndex].name);
      updateUI();
    }
  }

  function checkEndConditions(){ if(!getAlive(enemies).length){ battleOver=true; log('Victory! All pigs defeated.'); btnAttack.classList.add('disabled'); btnDefend.classList.add('disabled'); } if(!getAlive(players).length){ battleOver=true; log('Defeat... All birds knocked out.'); btnAttack.classList.add('disabled'); btnDefend.classList.add('disabled'); } }

  canvas.addEventListener('click', async (e)=>{ if(busy||battleOver) return; const rect=canvas.getBoundingClientRect(); const mx=(e.clientX-rect.left)*(canvas.width/DPR)/rect.width; const my=(e.clientY-rect.top)*(canvas.height/DPR)/rect.height; if(selectingTarget){ for(const en of enemies){ if(!en.alive) continue; const dx=mx-en.x, dy=my-en.y; if(Math.sqrt(dx*dx+dy*dy) < 52){ selectingTarget=false; btnAttack.classList.remove('disabled'); const attacker = players[currentPlayerIndex]; await performAttack(attacker, en); // after player acts, only one enemy acts
      await new Promise(r=>setTimeout(r,180));
      await enemySingleAction();
      return; } } } });

  btnAttack.addEventListener('click', ()=>{ if(busy||battleOver) return; btnAttack.classList.add('disabled'); selectingTarget=true; log('Select a pig to attack.'); });

  btnDefend.addEventListener('click', async ()=>{ if(busy||battleOver) return; const p = players[currentPlayerIndex]; p.defending = true; // defend reduces next damage by 50% for simplicity
    log(p.name + ' braces and will receive reduced damage next hit.');
    // after defending, an enemy performs a single action
    await new Promise(r=>setTimeout(r,150));
    await enemySingleAction();
  });

  btnRestart.addEventListener('click', ()=>{ resetGame(); btnAttack.classList.remove('disabled'); btnDefend.classList.remove('disabled'); });

  function loop(){ render(); requestAnimationFrame(loop); }

  (async function init(){ images.bg = await loadImage(ASSETS.bg);
    for(const p of ASSETS.players){ images.players.push(await loadImage(p)); }
    for(const e of ASSETS.enemies){ images.enemies.push(await loadImage(e)); }
    // Attach fallback sprites if some loaded nulls
    players = JSON.parse(JSON.stringify(defaultPlayers)); enemies = JSON.parse(JSON.stringify(defaultEnemies));
    // start
    resetGame(); loop();
  })();

  window.addEventListener('keydown',(e)=>{ if(e.key==='a') btnAttack.click(); if(e.key==='d') btnDefend.click(); if(e.key==='r') btnRestart.click(); });
  window._game = { players, enemies, resetGame };
  </script>
</body>
</html>
